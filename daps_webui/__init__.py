import os
from concurrent.futures import ThreadPoolExecutor
from pprint import pformat
from time import sleep

from flask import Flask
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy

from daps_webui.config.config import Config
from daps_webui.utils import webui_utils
from daps_webui.utils.logger_utils import get_daps_logger
from daps_webui.utils.webui_utils import get_instances
from DapsEX.border_replacerr import BorderReplacerr
from DapsEX.drive_sync import DriveSync
from DapsEX.plex_upload import PlexUploaderr
from DapsEX.poster_renamerr import PosterRenamerr
from DapsEX.unmatched_assets import UnmatchedAssets
from progress import ProgressState, progress_instance

# all globals needs to be defined here
global_config = Config()
db = SQLAlchemy()
migrate = Migrate()
executor = ThreadPoolExecutor(max_workers=3)

# define all loggers
daps_logger = get_daps_logger()


def create_app() -> Flask:
    # init flask app
    app = Flask(__name__)
    app.config.from_object(global_config)

    # initiate database
    db.init_app(app)
    migrate.init_app(app, db)

    if app.debug:
        with app.app_context():
            version = os.getenv("VERSION", "0.0.1")
            daps_logger.info(f"Starting daps-ui v{version}")
            daps_logger.info("Initializing database schema...")
            db.create_all()
            with db.engine.connect() as conn:
                conn.execute(db.text("PRAGMA journal_mode=WAL;"))
            daps_logger.info("WAL mode enabled for SQLite database")

    # import needed blueprints
    from daps_webui.views.home.home import home
    from daps_webui.views.poster_renamer.poster_renamer import poster_renamer
    from daps_webui.views.settings.settings import settings

    # register blueprints
    app.register_blueprint(home)
    app.register_blueprint(settings)
    app.register_blueprint(poster_renamer)

    return app


def run_renamer_task(webhook_item: dict | None = None):
    from daps_webui.models import PlexInstance, RadarrInstance, SonarrInstance

    try:
        radarr = get_instances(RadarrInstance())
        sonarr = get_instances(SonarrInstance())
        plex = get_instances(PlexInstance())
        poster_renamer_payload = webui_utils.create_poster_renamer_payload(
            radarr, sonarr, plex
        )
        daps_logger.debug("Poster Renamerr Payload:")
        daps_logger.debug(pformat(poster_renamer_payload))

        job_id = progress_instance.add_job()
        daps_logger.info(f"Job Poster Renamerr: '{job_id}' added.")

        renamer = PosterRenamerr(poster_renamer_payload)

        def check_borders() -> bool:
            from daps_webui.utils.database import Database

            with app.app_context():
                db_instance = Database(db, daps_logger)
                first_file_settings = db_instance.get_first_file_settings()
                if not first_file_settings:
                    return False
                return (
                    first_file_settings.get("border_setting")
                    != poster_renamer_payload.border_setting
                    or first_file_settings.get("custom_color")
                    != poster_renamer_payload.custom_color
                )

        def remove_job():
            try:
                progress_instance(job_id, 100, ProgressState.COMPLETED)
            except Exception as e:
                daps_logger.error(f"Error removing job {job_id}: {e}")
            finally:
                sleep(2)
                progress_instance.remove_job(job_id)
                daps_logger.info(f"Poster Renamerr Job: {job_id} has been removed")

        def run_renamerr_callback(fut):
            try:
                daps_logger.info("Renamerr task completed")
                media_dict = fut.result()
                if poster_renamer_payload.unmatched_assets:
                    unmatched_future = executor.submit(
                        handle_unmatched_assets_task, radarr, sonarr, plex, chained=True
                    )
                    if poster_renamer_payload.upload_to_plex:
                        unmatched_future.add_done_callback(
                            lambda fut: run_unmatched_after_renamerr_callback(
                                media_dict, fut
                            )
                        )
                    else:
                        remove_job()

                elif poster_renamer_payload.upload_to_plex:
                    if media_dict:
                        daps_logger.debug(f"Media dict from renamer: {media_dict}")
                    else:
                        daps_logger.warning(
                            "No media dict from renamer. Proceeding with full upload."
                        )
                    plex_upload_future = executor.submit(
                        handle_plex_uploaderr_task,
                        plex,
                        radarr,
                        sonarr,
                        media_dict,
                        chained=True,
                    )
                    plex_upload_future.add_done_callback(run_plex_upload_callback)
                else:
                    remove_job()

            except Exception as e:
                daps_logger.error(f"Error in plex upload callback: {e}")

        def run_border_replacerr_callback(fut):
            try:
                daps_logger.info("Border replacerr task completed.")
                renamer_future = executor.submit(renamer.run, progress_instance, job_id)
                renamer_future.add_done_callback(run_renamerr_callback)
            except Exception as e:
                daps_logger.error(f"Error in run_border_replacerr_callback: {e}")

        def run_unmatched_after_renamerr_callback(media_dict, fut):
            try:
                daps_logger.info("Unmatched assets task completed.")
                if media_dict:
                    daps_logger.debug(f"Media dict from renamer: {media_dict}")
                else:
                    daps_logger.warning(
                        "No media dict from renamer. Proceeding with full upload."
                    )
                plex_upload_future = executor.submit(
                    handle_plex_uploaderr_task,
                    plex,
                    radarr,
                    sonarr,
                    media_dict,
                    chained=True,
                )
                plex_upload_future.add_done_callback(run_plex_upload_callback)
            except Exception as e:
                daps_logger.error(
                    f"Error in run_unmatched_after_renamerr_callback: {e}"
                )

        def run_plex_upload_callback(fut):
            daps_logger.info("Plex uploaderr task completed.")
            remove_job()

        def run_unmatched_assets_only_unmatched_callback(fut):
            try:
                daps_logger.info("Unmatched assets task completed.")
                if check_borders():
                    border_replacerr_future = executor.submit(run_border_replacer_task)
                    border_replacerr_future.add_done_callback(
                        run_border_replacerr_callback
                    )
                else:
                    renamer_future = executor.submit(
                        renamer.run, progress_instance, job_id
                    )
                    renamer_future.add_done_callback(run_renamerr_callback)
            except Exception as e:
                daps_logger.error(
                    f"Error in run_unmatched_assets_only_unmatched_callback: {e}"
                )

        def run_drive_sync_callback(fut):
            try:
                daps_logger.info("Drive sync task completed.")
                if (
                    poster_renamer_payload.unmatched_assets
                    and poster_renamer_payload.only_unmatched
                ):
                    unmatched_future = executor.submit(
                        handle_unmatched_assets_task,
                        radarr,
                        sonarr,
                        plex,
                        chained=True,
                    )
                    unmatched_future.add_done_callback(
                        run_unmatched_assets_only_unmatched_callback
                    )
                else:
                    renamer_future = executor.submit(
                        renamer.run, progress_instance, job_id
                    )
                    renamer_future.add_done_callback(run_renamerr_callback)
            except Exception as e:
                daps_logger.error(f"Error in run_drive_sync_callback: {e}")

        if webhook_item:
            daps_logger.debug("Submitting webhook task to thread pool")
            future = executor.submit(
                renamer.run,
                progress_instance,
                job_id,
                webhook_item,
            )
            future.add_done_callback(run_renamerr_callback)
        else:
            if poster_renamer_payload.drive_sync:
                daps_logger.info("Starting drive sync task before renamer...")
                drive_sync_future = executor.submit(run_drive_sync_task, chained=True)
                drive_sync_future.add_done_callback(run_drive_sync_callback)
            elif (
                poster_renamer_payload.unmatched_assets
                and poster_renamer_payload.only_unmatched
            ):
                unmatched_future = executor.submit(
                    handle_unmatched_assets_task, radarr, sonarr, plex, chained=True
                )
                unmatched_future.add_done_callback(
                    run_unmatched_assets_only_unmatched_callback
                )
            else:
                renamer_future = executor.submit(renamer.run, progress_instance, job_id)
                renamer_future.add_done_callback(run_renamerr_callback)

        daps_logger.debug("Returning response: Poster renamer task started")
        return {
            "message": "Poster renamer task started",
            "job_id": job_id,
            "success": True,
        }
    except Exception as e:
        daps_logger.error(f"Error in Poster Renamer Task: {str(e)}")
        return {"success": False, "message": str(e)}


def run_border_replacer_task(chained: bool = False) -> dict:
    try:
        from daps_webui.utils.database import Database

        db_instance = Database(db, daps_logger)
        first_file_settings = db_instance.get_first_file_settings()

        border_replacerr_payload = webui_utils.create_border_replacer_payload()
        border_setting = border_replacerr_payload.border_setting
        custom_color = border_replacerr_payload.custom_color

        def remove_job_cb(fut):
            try:
                fut.result()
            except Exception as e:
                daps_logger.error(f"Error removing job {job_id}: {e}")
            finally:
                sleep(2)
                progress_instance.remove_job(job_id)
                daps_logger.info(f"Border Replacer Job: {job_id} has been removed")

        if first_file_settings:
            current_border_setting = first_file_settings.get("border_setting")
            current_custom_color = first_file_settings.get("custom_color")

            if (
                current_border_setting == border_setting
                and current_custom_color == custom_color
            ):
                daps_logger.info(
                    "Skipping task: Border and color settings already applied to files."
                )
                return {
                    "message": "Border and color settings already applied. Task skipped.",
                    "success": True,
                    "job_id": None,
                }

        job_id = progress_instance.add_job()
        daps_logger.debug(f"Job Border Replacerr: '{job_id}' added.")
        daps_logger.debug("Border Replacerr Payload:")
        daps_logger.debug(pformat(border_replacerr_payload))
        border_replacerr = BorderReplacerr(
            custom_color=None, payload=border_replacerr_payload
        )
        if chained:
            border_replacerr.replace_current_assets(progress_instance, job_id)
            progress_instance.remove_job(job_id)
            daps_logger.info(f"Border Replacer Job: {job_id} has been removed")
        else:
            daps_logger.debug("Submitting border replacerr task to thread pool")
            future = executor.submit(
                border_replacerr.replace_current_assets, progress_instance, job_id
            )
            future.add_done_callback(remove_job_cb)

        return {
            "message": "Border replacer task started",
            "job_id": job_id,
            "success": True,
        }

    except Exception as e:
        daps_logger.error(f"Error in Border Replacer Task: {str(e)}")
        return {"success": False, "message": str(e)}


def handle_unmatched_assets_task(radarr, sonarr, plex, chained: bool = False) -> dict:
    try:
        with app.app_context():
            unmatched_assets_payload = webui_utils.create_unmatched_assets_payload(
                radarr, sonarr, plex
            )
            daps_logger.debug("Unmatched Assets Payload:")
            daps_logger.debug(pformat(unmatched_assets_payload))
            job_id = progress_instance.add_job()
            daps_logger.info(f"Job Unmatched Assets: '{job_id}' added.")
            unmatched_assets = UnmatchedAssets(unmatched_assets_payload)

            def remove_job_cb(fut):
                try:
                    fut.result()
                except Exception as e:
                    daps_logger.error(f"Error removing job {job_id}: {e}")
                finally:
                    sleep(2)
                    progress_instance.remove_job(job_id)
                    daps_logger.info(f"Unmatched Assets Job: {job_id} has been removed")

            if chained:
                unmatched_assets.run(progress_instance, job_id)
                progress_instance.remove_job(job_id)
                daps_logger.info(f"Unmatched Assets Job: {job_id} has been removed")
            else:
                daps_logger.debug("Submitting unmatched assets task to thread pool")
                future = executor.submit(
                    unmatched_assets.run,
                    progress_instance,
                    job_id,
                )
                daps_logger.debug("Task submitted successfully")
                future.add_done_callback(remove_job_cb)

            return {
                "message": "Unmatched assets task started",
                "job_id": job_id,
                "success": True,
            }

    except Exception as e:
        daps_logger.error(f"Error in Unmatched Assets Task: {str(e)}")
        return {"success": False, "message": str(e)}


def handle_plex_uploaderr_task(
    plex,
    radarr,
    sonarr,
    webhook_item: dict | None = None,
    media_dict: dict | None = None,
    chained: bool = False,
) -> dict:
    with app.app_context():
        plex_uploader_payload = webui_utils.create_plex_uploader_payload(
            radarr, sonarr, plex
        )
        daps_logger.debug("Plex Uploaderr Payload:")
        daps_logger.debug(pformat(plex_uploader_payload))

        job_id = progress_instance.add_job()
        daps_logger.info(f"Job Plex Uploaderr: '{job_id}' added.")

        def remove_job_cb(fut):
            try:
                fut.result()
            except Exception as e:
                daps_logger.debug(f"Error removing job {job_id}: {e}")
            finally:
                sleep(2)
                progress_instance.remove_job(job_id)
                daps_logger.info(f"Plex uploaderr: {job_id} has been removed")

        if webhook_item and media_dict:
            plex_uploaderr = PlexUploaderr(
                plex_uploader_payload,
                webhook_item=webhook_item,
                media_dict=media_dict,
            )
            daps_logger.debug("Submitting webhook plex uploaderr task to thread pool")
            future = executor.submit(
                plex_uploaderr.upload_posters_webhook,
            )
            daps_logger.debug("Task submitted successfully")
        else:
            plex_uploaderr = PlexUploaderr(plex_uploader_payload)

            if chained:
                plex_uploaderr.upload_posters_full(progress_instance, job_id)
                progress_instance.remove_job(job_id)
                daps_logger.info(f"Plex uploaderr: {job_id} has been removed")
            else:
                daps_logger.debug("Submitting plex uploaderr task to thread pool")
                future = executor.submit(
                    plex_uploaderr.upload_posters_full,
                    progress_instance,
                    job_id,
                )
                future.add_done_callback(remove_job_cb)

        return {
            "message": "Plex uploaderr task started",
            "job_id": job_id,
            "success": True,
        }


def run_unmatched_assets_task():
    from daps_webui.models import PlexInstance, RadarrInstance, SonarrInstance

    try:
        radarr = get_instances(RadarrInstance())
        sonarr = get_instances(SonarrInstance())
        plex = get_instances(PlexInstance())

        return handle_unmatched_assets_task(radarr, sonarr, plex)
    except Exception as e:
        return {"success": False, "message": str(e)}


def run_plex_uploaderr_task():
    from daps_webui.models import PlexInstance, RadarrInstance, SonarrInstance

    try:
        radarr = get_instances(RadarrInstance())
        sonarr = get_instances(SonarrInstance())
        plex = get_instances(PlexInstance())

        return handle_plex_uploaderr_task(plex, radarr, sonarr)
    except Exception as e:
        return {"success": False, "message": str(e)}


def run_drive_sync_task(chained: bool = False) -> dict:
    with app.app_context():
        daps_logger.info(f"run_drive_sync_task called with chained={chained}")
        payload = webui_utils.create_drive_sync_payload()
        daps_logger.debug("Drive Sync Payload:")
        daps_logger.debug(pformat(payload))
        job_id = progress_instance.add_job()
        daps_logger.info(f"Job Drive Sync: '{job_id}' added.")
        drive_sync = DriveSync(payload)

        def remove_job_cb(fut):
            try:
                fut.result()
                progress_instance(job_id, 100, ProgressState.COMPLETED)
            except Exception as e:
                daps_logger.debug(f"Error removing job {job_id}: {e}")
            finally:
                sleep(2)
                progress_instance.remove_job(job_id)
                daps_logger.info(f"Drive Sync: {job_id} has been removed")

        if chained:
            try:
                drive_sync.sync_all_drives(progress_instance, job_id)
                progress_instance.remove_job(job_id)
                daps_logger.info(f"Drive Sync: {job_id} has been removed")
            except Exception as e:
                daps_logger.error(f"Drive sync failed: {e}")
        else:
            future = executor.submit(
                drive_sync.sync_all_drives, progress_instance, job_id
            )
            future.add_done_callback(remove_job_cb)

        return {
            "message": "Drive Sync task started",
            "job_id": job_id,
            "success": True,
        }


app = create_app()

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
